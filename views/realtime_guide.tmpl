{% set appid = '{{appid}}' %}
{% set appkey = '{{appkey}}' %}
{% set masterkey = '{{masterkey}}' %}

#  {% block language %}{% endblock %} 实时通信开发指南

## 简介

实时通信服务可以帮你快速实现聊天和对话管理功能，比如单聊、群聊、建聊天室、管理群组成员、查询消息历史等等。所有聊天记录都保存在云端，离线消息会通过消息推送来及时送达，推送消息文本可以灵活进行定制。

在继续阅读本文档之前，请先阅读[《实时通信开发指南》](./realtime_v2.html)，了解一下实时通信的基本概念和模型。

{% block supportedRuntime %}{% endblock %}

### 文档贡献
我们欢迎和鼓励大家对本文档的不足提出修改建议。请访问我们的 [Github 文档仓库](https://github.com/leancloud/docs) 来提交 Pull Request。

## 安装
<!-- 导入 SDK /系统依赖库 / bower  -->
{% block setup %}{% endblock %}

## 初始化
{% block init %}{% endblock %}

## Demo
<!-- 概述一下 Demo 的功能，加入一张 Demo 的截屏/ github 地址 -->

## 单聊

我们先从最简单的环节入手。此场景类似于微信的私聊、微博的私信和 QQ 单聊。我们创建了一个统一的概念来描述聊天的各种场景：`AVIMConversation`（对话），在[《实时通信开发指南》](./realtime_v2.html) 里也有它的详细介绍。

### 发送消息

Tom 想给 Jerry 发一条消息，实现代码如下：

{% block oneOnOneChat_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 向 Jerry 发送消息：'耗子，起床！' 
```

### 接收消息

要让 Jerry 收到 Tom 的消息，需要这样写：

{% block oneOnOneChat_receive %}{% endblock %}
```
- 初始化 ClientId = Jerry 
- Jerry 登录到系统
- 设置接收消息的方法
```

执行完以上代码，在 LeanCloud 网站的控制台找到指定的应用，进入 **存储** > **数据** 页面，可以看到默认表 `_Conversation` 中多了一行数据，其字段含义如下：

名称|类型|描述
---|---|---
name|String|对话唯一的名字
m|Array|对话中成员的列表
lm|Date|对话中最后一条消息发送的时间
c|String|对话的创建者的 ClientId
mu|Array|对话中设置了静音的成员，仅针对 iOS 以及 Windows Phone 用户有效。
attr|Object|开发者设置的对话的自定义属性

> TODO: message 存在哪里？

## 群聊

此场景类似于微信的多人聊天群组和 QQ 的群。请注意这里的群聊是指可以**持久保存**的一个群组的概念，比如 QQ 群，除非群主解散该群，这个群会一直存在于我的 QQ 群的列表中。而临时群组聊天（即聊天室）会放到后面单独介绍。

### 发送消息

Tom 想建立一个群，把自己好朋友都拉进这个群，然后给他们发消息，他需要做的事情是：

第一步：建立一个朋友列表
第二步：新建一个对话，把朋友列为对话的参与人员
第三步：发送消息

{% block groupChat_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 建立一个朋友列表 friends：[Jerry, Bob, Harry, William]
- 新建对话，把朋友们列为对话的参与人员
- 发送消息：'Hey，你们在哪里？'
```
### 接收消息

群聊的接收消息与单聊的接收消息在代码写法上是一致的。

{% block groupChat_receive %}{% endblock %}
```
- 初始化 ClientId = Bob
- Bob 登录到系统
- 设置接收消息的方法
- Bob 收到消息后又回复了一条：@Tom, 我在 Jerry 家，你跟 Harry 什么时候过来？还有 William 和你在一起么？
```

以上由 Tom 和 Bob 发送的消息，William 在上线时都会收到。

由此可以看出，**群聊和单聊本质上都是对话**，只是参与人数不同。单聊是一对一的对话，群聊是多对多的对话。

{% block dotnetCreateConversationAsync %}{% endblock %}

## 消息
消息是对话的主要组成部分，我们支持的消息类型有：

- 文本消息　　：`AVIMTextMessage`
- 图像消息　　：`AVIMImageMessage`
- 音频消息　　：`AVIMAudioMessage`
- 视频消息　　：`AVIMVideoMessage`
- 文件消息　　：`AVIMFileMessage`
- 地理位置消息：`AVIMLocationMessage`

### 消息类型

#### 文本消息

##### 发送文本消息

文本消息是最基本的消息类型，要使用 `AVIMConversation` 的 `SendTextMessageAsync` 方法来发送。具体操作可参考上面 [单聊](#发送消息) 或 [群聊](#发送消息-1) 发送消息的示例。

##### 接收文本消息

客户端登录后可以通过 `AVIMClient` 中的 `OnMessageReceived` 方法来接收消息，如果接收方正好加载了这个对话，那么接收方在 `AVIMConversation` 里面也会收到 `OnTextMessageReceived` 的事件响应。

{% block textMessage_receive %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 从系统媒体库获取第一张照片
- 创建图像消息
- 给图像加一个自定义属性：location = 'San Francisco'
- 发送
```

#### 图像消息
图像可以从系统提供的拍照 API 或本地媒体库中获取，也可以用有效的图像 URL。先调用 SDK  方法构造出一个 `AVIMImageMessage` 对象，然后把它当做参数交由 `AVIMConversation` 发送出去即可。

##### 发送图像消息

【场景一】用系统自身提供的 API 去获取本地媒体库里的照片的数据流，然后构造出 `AVIMImageMessage` 来发送：

{% block imageMessage_local_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 从系统媒体库获取第一张照片
- 创建图像消息
- 给图像加一个自定义属性：location = 'San Francisco'
- 发送
```

【场景二】从微博上复制的一个图像链接来创建图像消息：

{% block imageMessage_url_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称是「猫和老鼠」
- 创建图像消息：http://pic2.zhimg.com/6c10e6053c739ed0ce676a0aff15cf1c.gif
- 混合文本：萌妹子一枚
- 发送
```
以上两种场景对于 SDK 的区别为：

* 场景一：SDK 获取了完整的图像数据流，先上传文件到服务端，再将文件的元数据以及 URL 等一并包装，发送出去。

* 场景二：SDK 并没有实际将图像上传到服务端，而仅仅把 URL 包装在消息体内发送出去，这种情况下接收方是无法从消息体中获取图像的元信息数据，但开发者可以自行获取。

##### 接收图像消息

{% block imageMessage_receive_intro %}{% endblock %}
类似于第一章节中单聊中的接收消息，客户端登录后可以通过 `AVIMClient` 中的 `OnMessageReceived` 方法来接收图像，如果接收方此时正好加载了这个对话，那么接收方在 `AVIMConversation` 里面也会收到 `OnImageMessageReceived` 的事件响应：

{% block imageMessage_receive %}{% endblock %}
```
- 初始化 ClientId = Jerry
- Jerry 登录到系统
- 获取对话 Id = 55117292e4b065f7ee9edd29
- 收取图像，获取相关元数据 MessageId、FromClientId、URL、Size、Width、Height、Format 等
```

#### 音频消息

##### 发送音频消息

发送音频消息的基本流程是：读取音频文件（或者录制音频）> 构建音频消息 > 消息发送。

{% block audioMessage_local_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 本地读取音频文件：忐忑.mp3 ，创建音频消息
- 加入文本：'听听人类的神曲~'
- 发送
``` 

与图像消息类似，音频消息也支持从 URL 构建：

{% block audioMessage_url_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 从外部链接创建音频消息：http://ac-lhzo7z96.clouddn.com/1427444393952
- 创建音频消息
- 发送
```

##### 接收音频消息

{% block audioMessage_receive_desc %}{% endblock %}
与接收图像消息类似，由 `AVIMConversation` 的 `OnAudioMessageReceived` 方法来响应，实例代码请参照 [图像消息接收](#接收图像消息)。

> TODO: 音频元信息提取/列表 [messageId, file.url, size, duration, format]

#### 视频消息

##### 发送视频消息

与发送音频消息的流程类似，视频的来源可以是手机录制，可以是系统中某一个具体的视频文件：

{% block videoMessage_local_send %}{% endblock %}

```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 打开本地文件夹
- 读取视频文件：奶酪.mp4，创建视频消息
- 发送
```

同样我们也支持从一个视频的 URL 创建视频消息，然后发送出去：

{% block videoMessage_url_send %}{% endblock %}

```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 从外部链接创建视频消息：http://ac-lhzo7z96.clouddn.com/1427267336319
- 发送给 Jerry
```

**注：这里说的 URL 指的是视频文件自身的 URL，而不是视频网站上播放页的 URL。**

##### 接收视频消息

与接收图像消息类似，由 `AVIMConversation` 的 `OnVideoMessageReceived` 方法 来响应，实例代码请参照 [图像消息接收](#接收图像消息)。

> TODO: 视频元信息提取/列表[messageId, file.url, size, duration, format] 

#### 通用文件消息

开发者可以用它来发送带附件的消息或离线文件。对于此类消息，LeanCloud IM SDK 内部会先把文件上传到 LeanCloud 文件存储服务器（自带 CDN 功能），然后把文件元数据（url、文件大小等）放在消息包内发送到 LeanCloud 实时通信服务端。

Tom 要发送一份 .doc 文件给 Jerry，可以用下面这种方法：

##### 发送通用文件消息

{% block fileMessage_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 打开本地文件夹
- 读取本地文件 leancloud.doc，构造 AVFile
- 发送
```

##### 接收通用文件消息
与接收图像消息类似，由 `AVIMConversation` 的 `OnFileMessageReceived` 方法来响应，实例代码请参照 [图像消息接收](#接收图像消息)。

> TODO: 文件元信息提取/列表 [messageId, FileUrl, Size]

#### 地理位置消息

地理位置消息构建方式有两种：

{% block locationMessage_new %}{% endblock %}
```
- 1.根据纬度和经度（latitude: 45.0 longitude:34.0）构建 
  AVIMLocationMessage()
- 2. AVGeoPoint 构建
  AVIMLocationMessage(
    AVGeoPoint(31.3853142377, 121.0553079844)
  )
```
##### 发送地理位置消息

{% block locationMessage_send %}{% endblock %}
```
- 初始化 ClientId = Tom
- Tom 登录到系统
- 创建与 Jerry 的对话，对话名称为「猫和老鼠」
- 以经度和纬度为参数构建一个地理位置消息 AVIMLocationMessage(138.12454, 52.56461)
- 加入文本：好利来新店！！
//开发者更可以通过具体的设备的 API 去获取设备的地理位置
- 发送
}
```

##### 接收地理位置消息

与接收图像消息类似， 由 `AVIMConversation` 的 `OnLocationMessageReceived` 方法来响应，实例代码请参照 [图像消息接收](#接收图像消息)。

> TODO: 文件元信息提取/列表 [messageId, latitude, longitude]

#### 自定义消息

##### 消息类详解

我们所支持的文本、图像、语音、视频、文件、地理位置等富媒体消息类型都有一个共同的基类：`AVIMTypedMessage`。

![消息的类图](http://ac-lhzo7z96.clouddn.com/1427252943504)

层级|类名|说明|类型
:---:|---|---|---
一|`AVIMMessage`|所有消息的基类|抽象类
二|`AVIMTypedMessage`| 富媒体消息的基类|抽象类
三|`AVIMTextMessage`|文本消息|实例类
三|`AVIMLocationMessage`|地理位置消息|实例类
三|`AVIMFileMessageBase`| 所有包含了文件内容的消息的基类|抽象类
四|`AVIMImageMessage`|图像消息|实例类
四|`AVIMAudioMessage`|音频消息|实例类
四|`AVIMVideoMessage`|视频消息|实例类
四|`AVIMFileMessage`|通用文件消息类|实例类

结合图例，实时通信 SDK 在封装的时候做了明确的分层，开发者需要根据自己的需求去使用。

我们为每一种富媒体消息定义了一个消息类型，LeanCloud SDK 自身使用的类型是负数（如下面列表所示），所有正数留给开发者自定义扩展类型使用，0 作为「没有类型」被保留起来。

消息 | 类型
--- | ---
文本消息|-1
图像消息|-2
音频消息|-3
视频消息|-4
位置消息|-5
文件消息|-6

##### 消息的自定义属性

在有些场景下，开发者需要在发送消息时附带上自己业务逻辑需求的自定义属性，比如消息发送的设备名称，或是图像消息的拍摄地点、视频消息的来源等等，开发者可以通过 `AVIMMessage.Attributes` 实现这一需求。

【场景一】发照片给朋友时，想告诉对方照片是在旧金山照的：

```c#
AVIMImageMessage imgMessage = new AVIMImageMessage(photo.Name, photo.GetImage());//构造 AVIMImageMessage
imgMessage.Attributes = new Dictionary<string, object>() 
{ 
    {"location","San Francisco"}
};
imgMessage.Title = "发自我的WP";
await conversation.SendImageMessageAsync(imgMessage);
```

接收方在 `OnMessageReceived` 的时候是可以读取到这一属性：

```c#
AVIMClient client = new AVIMClient("friend");
await client.ConnectAsync();
client.OnMessageReceieved += (s, e) =>
{
    if (e.Message is AVIMImageMessage)
    {
        AVIMImageMessage imgMessage = (AVIMImageMessage)e.Message;
        string url = imgMessage.Url;
        string location = imgMessage.Attributes["location"].ToString();//读取的结果就是 San Francisco
    }
};
```
所有消息都支持 Attributes 这一属性。

> 什么时候需要扩展自己的富媒体消息？

譬如有一条图像消息，除了文本之外，还需要附带地理位置信息，为此开发者需要创建一个新的消息类型吗？其实完全没有必要。这种情况只要使用消息类中预留的 attributes 属性就可以保存额外的地理位置信息了。

只有在我们的消息类型完全无法满足需求的时候，才需要扩展自己的消息类型。譬如「今日头条」里面允许用户发送某条新闻给好友，在展示上需要新闻的标题、摘要、图片等信息（类似于微博中的 linkcard）的话，这时候就可以扩展一个新的 NewsMessage 类。

### 消息的接收和发送策略

#### 接收策略

消息接收分为**两个层级**：

* 第一个是在 `AVIMClient` 上，它是为了帮助开发者实现被动接收消息，尤其是在本地并没有加载任何对话的时候，类似于刚登录，本地并没有任何 `AVIMConversation` 的时候，如果某个对话产生新的消息，当前 `AVIMClient.OnMessageReceived` 负责接收这类消息，但是它并没有针对消息的类型做区分。

* 第二个是在 `AVIMConversation` 上，负责接收对话的全部信息，并且针对不同的消息类型有不同的事件类型做响应。

以上 **2** 个层级的消息接收策略可以用下表进行描述，假如正在接收的是 `AVIMTextMessage`：

AVIMClient 接收端 | 条件① |条件② |条件③ | 条件④ |条件⑤ 
:----------- | :------------ | :------------- | :------------- | :------------- | :-------------
AVIMClient.OnMessageReceived | × | √ | √ | √ | √
AVIMConversation.OnMessageReceived | × | × | √ | × | × 
AVIMConversation.OnTypedMessageReceived| × | × | × | √ | × 
AVIMConversation.OnTextMessageReceived | × | × | × | × | √ 

对应条件如下：

* 条件①：
```c#
AVIMClient.Status != Online
``` 
* 条件②：
```c#
AVIMClient.Status == Online && AVIMClient.OnMessageReceived != null
```
* 条件③：
```c#
AVIMClient.Status == Online 
&& AVIMClient.OnMessageReceived != null 
&& AVIMConversation.OnMessageReceived != null
```
* 条件④：
```c#
AVIMClient.Status == Online 
&& AVIMClient.OnMessageReceived != null 
&& AVIMConversation.OnMessageReceived != null
&& AVIMConversation.OnTypedMessageReceived != null
&& AVIMConversation.OnTextMessageReceived == null
```

* 条件⑤：
```c#
AVIMClient.Status == Online 
&& AVIMClient.OnMessageReceived != null 
&& AVIMConversation.OnMessageReceived != null
&& AVIMConversation.OnTypedMessageReceived != null
&& AVIMConversation.OnTextMessageReceived != null
```

在 AVIMConversation 内，接收消息的顺序为： 

> OnTextMessageReceived > OnTypedMessageReceived > OnMessageReceived

这是为了方便开发者在接收消息的时候有一个分层操作的空间，这一特性也适用于其他富媒体消息。

#### 发送策略

开发者在阅读完前面的富媒体消息并且运行过实例代码之后，在 Visual Studio 中使用 F12 快捷键查看各个消息类型的定义，应该可以看见图像、音频、视频在类的继承关系上是继承自 `AVIMFileMessageBase`，所有继承自 `AVIMFileMessageBase` 的消息类型的发送策略如下：

* 如果文件是从客户端 API 读取的数据流 (Stream) 

  * 第一步：从本地构造 AVFile
  * 第二步：调用 AVFile 的上传的方法上传到服务器，并获取文件的元信息（MetaData）
  * 第三步：把 AVFile 的 objectId 以及 URL ，以及文件的元信息封装在消息体内
  * 第四步：发送消息

* 如果文件是外部链接的 URL
  * 第一步：直接将 URL 封装在消息体内，不获取元信息，不包含 objectId
  * 第二步：发送消息

以上逻辑对所有继承 `AVIMFileMessageBase` 的消息类型有效，目前 SDK 内置的继承自 `AVIMFileMessageBase` 包含以下几种：

* AVIMImageMessage
* AVIMAudioMessage
* AVIMVideoMessage
* AVIMFileMessage

##### 接收离线消息
##### 消息送达回执
##### 消息已读回执


## 对话

### 对话的属性
#### 名称
#### 成员
#### 创建者
#### 静音成员
#### 自定义属性

#### 对话的管理
##### 自身主动加入
……
##### 剔除其他成员

#### 对话的查询
##### 基础查询
###### 根据 id 查询
###### 获取对话列表

##### 条件查询
###### 比较查询
###### 正则匹配查询
###### 包含查询

##### 组合查询
##### 计数查询 

## 聊天室
### 创建聊天室
### 查询在线人数
### 查询聊天室
#### 获取聊天室列表

## 聊天记录
### 聊天记录的获取

## 签名与安全





